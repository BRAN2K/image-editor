This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-31T13:51:35.793Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repopack, visit: https://github.com/yamadashy/repopack

# Repository Structure
```
src/
  app/
    editor/
      page.tsx
    layout.tsx
    page.tsx
  components/
    ImageEditor/
      CanvasArea/
        index.tsx
        style.ts
      CanvasElements/
        EditableTextArea.tsx
        ImageLayer.tsx
        LayerTransformer.tsx
        ResizableText.tsx
        style.ts
        TextLayer.tsx
      Editor/
        index.tsx
        style.ts
      ElementList/
        index.tsx
        style.ts
      LayerItem/
        index.tsx
        style.ts
      LayerList/
        index.tsx
        style.ts
  state/
    atoms.ts
  types/
    index.ts
```

# Repository Files

## File: src/app/editor/page.tsx
```typescript
'use client';

import dynamic from 'next/dynamic';
import React from 'react';
import { RecoilRoot } from 'recoil'; // Importa o RecoilRoot

// Importação dinâmica para evitar SSR do Konva
const Editor = dynamic(() => import('@/components/ImageEditor/Editor'), {
  ssr: false,
});

const Home: React.FC = () => {
  return (
    <RecoilRoot>
      <div>
        <Editor />
      </div>
    </RecoilRoot>
  );
};

export default Home;
```

## File: src/app/layout.tsx
```typescript
import GlobalStyle from '@/themes/globalStyle';
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Editor de Imagem',
  description: 'Editor de Imagem',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <GlobalStyle />
      <html lang="pt-BR">
        <body>{children}</body>
      </html>
    </>
  );
}
```

## File: src/app/page.tsx
```typescript
'use client';

import styled from 'styled-components';

const Principal = () => {
  return <Main>{/* <Cover /> */}</Main>;
};

export default Principal;

const Main = styled.main`
  width: 100%;
  height: 100vh;
`;
```

## File: src/components/ImageEditor/CanvasArea/index.tsx
```typescript
// src/components/ImageEditor/CanvasArea/index.tsx

import React, { useRef } from 'react';
import { Layer } from 'react-konva';
import { Canva, CanvasContainer } from './style';
import { useRecoilValue, useSetRecoilState } from 'recoil';
import { layersState, selectedLayerIdState } from '@/state/atoms';
import ImageLayer from '../CanvasElements/ImageLayer';
import TextLayer from '../CanvasElements/TextLayer';
import LayerTransformer from '../CanvasElements/LayerTransformer';
import Konva from 'konva';

const CanvasArea: React.FC = () => {
  const layers = useRecoilValue(layersState);
  const setSelectedLayerId = useSetRecoilState(selectedLayerIdState);

  const stageRef = useRef<Konva.Stage>(null);
  const shapeRefs = useRef<{ [key: string]: Konva.Node }>({});

  // Manipula cliques no Stage para deselecionar camadas
  const handleStageMouseDown = (e: any) => {
    // Se clicou na área vazia, deseleciona a camada
    if (e.target === e.target.getStage()) {
      setSelectedLayerId(null);
    }
  };

  return (
    <CanvasContainer>
      <Canva
        ref={stageRef}
        width={window.innerHeight - 200} // Ajuste conforme a largura da sidebar
        height={window.innerHeight - 200}
        onMouseDown={handleStageMouseDown}>
        <Layer>
          {layers
            .filter((layer) => layer.visible)
            .sort((a, b) => a.zIndex - b.zIndex)
            .map((layer) => {
              if (layer.type === 'image' && layer.image) {
                return <ImageLayer key={layer.id} layer={layer} shapeRefs={shapeRefs} />;
              } else if (layer.type === 'text') {
                return <TextLayer key={layer.id} layer={layer} shapeRefs={shapeRefs} stageRef={stageRef} />;
              } else {
                return null;
              }
            })}
          {/* Componente do Transformer */}
          <LayerTransformer shapeRefs={shapeRefs} />
        </Layer>
      </Canva>
    </CanvasContainer>
  );
};

export default CanvasArea;
```

## File: src/components/ImageEditor/CanvasArea/style.ts
```typescript
import { Stage } from 'react-konva';
import styled from 'styled-components';

export const CanvasContainer = styled.div`
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #e3e3e3;
`;

export const Canva = styled(Stage)`
  border: 2px solid #000;
  background-color: #ffffff;
`;
```

## File: src/components/ImageEditor/CanvasElements/EditableTextArea.tsx
```typescript
// src/components/ImageEditor/CanvasElements/EditableTextArea.tsx

import React, { useEffect, useRef } from 'react';
import { Html } from 'react-konva-utils';
import { useRecoilState } from 'recoil';
import { layersState } from '@/state/atoms';
import { LayerType } from '@/types';
import { StyledTextarea } from './style';

interface EditableTextAreaProps {
  layer: LayerType;
  onFinishEditing: () => void;
}

const EditableTextArea: React.FC<EditableTextAreaProps> = ({ layer, onFinishEditing }) => {
  const [layers, setLayers] = useRecoilState(layersState);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }
  }, []);

  const updateLayer = (id: string, attrs: Partial<LayerType>) => {
    setLayers((prevLayers) =>
      prevLayers.map((layerItem) => (layerItem.id === id ? { ...layerItem, ...attrs } : layerItem))
    );
  };

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    updateLayer(layer.id, { text: e.target.value });
  };

  const handleBlur = () => {
    onFinishEditing();
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
      e.preventDefault();
      onFinishEditing();
    }
  };

  return (
    <Html>
      <StyledTextarea
        ref={textareaRef}
        value={layer.text}
        x={layer.x}
        y={layer.y}
        rotation={layer.rotation}
        width={layer.width}
        fontSize={layer.fontSize}
        fontFamily={layer.fontFamily}
        fill={layer.fill}
        onChange={handleChange}
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
      />
    </Html>
  );
};

export default EditableTextArea;
```

## File: src/components/ImageEditor/CanvasElements/ImageLayer.tsx
```typescript
// src/components/ImageEditor/CanvasElements/ImageLayer.tsx

import React, { useEffect } from 'react';
import { Image as KonvaImage } from 'react-konva';
import { LayerType } from '@/types';
import { useRecoilState } from 'recoil';
import { selectedLayerIdState, layersState } from '@/state/atoms';
import Konva from 'konva';

interface ImageLayerProps {
  layer: LayerType;
  shapeRefs: React.MutableRefObject<{ [key: string]: Konva.Node }>;
}

const ImageLayer: React.FC<ImageLayerProps> = ({ layer, shapeRefs }) => {
  const [selectedLayerId, setSelectedLayerId] = useRecoilState(selectedLayerIdState);
  const [layers, setLayers] = useRecoilState(layersState);

  const isSelected = layer.id === selectedLayerId;

  const onSelect = () => {
    setSelectedLayerId(layer.id);
  };

  const updateLayer = (id: string, attrs: Partial<LayerType>) => {
    setLayers((prevLayers) =>
      prevLayers.map((layerItem) => (layerItem.id === id ? { ...layerItem, ...attrs } : layerItem))
    );
  };

  return (
    <KonvaImage
      key={layer.id}
      image={layer.image}
      x={layer.x}
      y={layer.y}
      width={layer.width}
      height={layer.height}
      rotation={layer.rotation}
      draggable={!layer.locked}
      ref={(node) => {
        if (node) {
          shapeRefs.current[layer.id] = node;
        } else {
          delete shapeRefs.current[layer.id];
        }
      }}
      onClick={onSelect}
      onTap={onSelect}
      onDragEnd={(e) => {
        const node = e.target;
        updateLayer(layer.id, {
          x: node.x(),
          y: node.y(),
        });
      }}
      onTransformEnd={(e) => {
        const node = e.target;
        const scaleX = node.scaleX();
        const scaleY = node.scaleY();

        updateLayer(layer.id, {
          x: node.x(),
          y: node.y(),
          rotation: node.rotation(),
          width: Math.max(5, node.width() * scaleX),
          height: Math.max(5, node.height() * scaleY),
        });

        node.scaleX(1);
        node.scaleY(1);
      }}
    />
  );
};

export default ImageLayer;
```

## File: src/components/ImageEditor/CanvasElements/LayerTransformer.tsx
```typescript
// src/components/ImageEditor/CanvasElements/LayerTransformer.tsx

import React, { useEffect } from 'react';
import { Transformer } from 'react-konva';
import { useRecoilValue } from 'recoil';
import { selectedLayerIdState } from '@/state/atoms';
import Konva from 'konva';

interface LayerTransformerProps {
  shapeRefs: React.MutableRefObject<{ [key: string]: Konva.Node }>;
}

const LayerTransformer: React.FC<LayerTransformerProps> = ({ shapeRefs }) => {
  const selectedLayerId = useRecoilValue(selectedLayerIdState);
  const transformerRef = React.useRef<Konva.Transformer>(null);

  useEffect(() => {
    const transformer = transformerRef.current;
    const selectedNode = selectedLayerId ? shapeRefs.current[selectedLayerId] : null;

    if (transformer && selectedNode) {
      // Vincula o Transformer ao nó selecionado
      transformer.nodes([selectedNode]);
      transformer.getLayer()?.batchDraw();
    } else {
      // Remove o Transformer se nenhuma camada estiver selecionada
      transformer?.detach();
      transformer?.getLayer()?.batchDraw();
    }
  }, [selectedLayerId, shapeRefs]);

  return (
    <Transformer
      ref={transformerRef}
      rotateEnabled={true}
      anchorSize={7}
      enabledAnchors={[
        'top-left',
        'top-center',
        'top-right',
        'middle-left',
        'middle-right',
        'bottom-left',
        'bottom-center',
        'bottom-right',
      ]}
      boundBoxFunc={(oldBox, newBox) => {
        if (newBox.width < 5 || newBox.height < 5) {
          return oldBox;
        }
        return newBox;
      }}
    />
  );
};

export default LayerTransformer;
```

## File: src/components/ImageEditor/CanvasElements/ResizableText.tsx
```typescript
import React from 'react';
import { Text as KonvaText } from 'react-konva';
import { useRecoilState } from 'recoil';
import { layersState } from '@/state/atoms';
import { LayerType } from '@/types';
import Konva from 'konva';

interface ResizableTextProps {
  layer: LayerType;
  shapeRefs: React.MutableRefObject<{ [key: string]: Konva.Node }>;
  onSelect: () => void;
  onDblClick: () => void;
}

const ResizableText: React.FC<ResizableTextProps> = ({ layer, shapeRefs, onSelect, onDblClick }) => {
  const [layers, setLayers] = useRecoilState(layersState);

  const updateLayer = (id: string, attrs: Partial<LayerType>) => {
    setLayers((prevLayers) =>
      prevLayers.map((layerItem) => (layerItem.id === id ? { ...layerItem, ...attrs } : layerItem))
    );
  };

  return (
    <KonvaText
      text={layer.text}
      x={layer.x}
      y={layer.y}
      rotation={layer.rotation}
      fontSize={layer.fontSize}
      fontFamily={layer.fontFamily}
      fill={layer.fill}
      draggable={!layer.locked}
      ref={(node) => {
        if (node) {
          shapeRefs.current[layer.id] = node;
        } else {
          delete shapeRefs.current[layer.id];
        }
      }}
      onClick={onSelect}
      onTap={onSelect}
      onDblClick={onDblClick}
      onDragEnd={(e) => {
        const node = e.target;
        updateLayer(layer.id, {
          x: node.x(),
          y: node.y(),
        });
      }}
      onTransformEnd={(e) => {
        const node = e.target;
        const scaleY = node.scaleY();

        updateLayer(layer.id, {
          x: node.x(),
          y: node.y(),
          rotation: node.rotation(),
          fontSize: Math.max(5, layer.fontSize! * scaleY),
        });

        node.scaleX(1);
        node.scaleY(1);
      }}
    />
  );
};

export default ResizableText;
```

## File: src/components/ImageEditor/CanvasElements/style.ts
```typescript
import styled from 'styled-components';

interface TextAreaProps {
  x: number;
  y: number;
  rotation: number;
  width: number;
  fontSize?: number;
  fontFamily?: string;
  fill?: string;
}

export const StyledTextarea = styled.textarea<TextAreaProps>`
  position: absolute;
  top: 0;
  left: 0;
  width: ${(props) => `${props.width}px`};
  height: auto;
  font-size: ${(props) => `${props.fontSize}px`};
  font-family: ${(props) => props.fontFamily || 'Arial'};
  color: ${(props) => props.fill || '#000000'};
  background: transparent;
  border: none;
  outline: none;
  resize: none;
  overflow: hidden;
  transform-origin: left top;
  transform: ${(props) => `translate(${props.x}px, ${props.y}px) rotate(${props.rotation}deg)`};
  padding: 0;
  margin: 0;
  white-space: pre-wrap;
  line-height: 1;
`;
```

## File: src/components/ImageEditor/CanvasElements/TextLayer.tsx
```typescript
import React, { useState } from 'react';
import { useRecoilState } from 'recoil';
import { selectedLayerIdState } from '@/state/atoms';
import ResizableText from './ResizableText';
import EditableTextArea from './EditableTextArea';
import { LayerType } from '@/types';
import Konva from 'konva';

interface TextLayerProps {
  layer: LayerType;
  shapeRefs: React.MutableRefObject<{ [key: string]: Konva.Node }>;
}

const TextLayer: React.FC<TextLayerProps> = ({ layer, shapeRefs }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [selectedLayerId, setSelectedLayerId] = useRecoilState(selectedLayerIdState);

  const handleDblClick = () => {
    setIsEditing(true);
  };

  const onSelect = () => {
    setSelectedLayerId(layer.id);
  };

  const handleFinishEditing = () => {
    setIsEditing(false);
  };

  return (
    <>
      {isEditing ? (
        <EditableTextArea layer={layer} onFinishEditing={handleFinishEditing} />
      ) : (
        <ResizableText layer={layer} shapeRefs={shapeRefs} onSelect={onSelect} onDblClick={handleDblClick} />
      )}
    </>
  );
};

export default TextLayer;
```

## File: src/components/ImageEditor/Editor/index.tsx
```typescript
// src/components/ImageEditor/Editor/index.ts
import React from 'react';
import LayerList from '../LayerList';
import CanvasArea from '../CanvasArea';
import { v4 as uuidv4 } from 'uuid';
import { LayerType } from '@/types';
import { EditorContainer, TopBar, Content } from './style';
import { useRecoilState } from 'recoil';
import { layersState } from '@/state/atoms';
import ElementList from '../ElementList';

const Editor: React.FC = () => {
  const handleExport = () => {
    // Implementação da exportação aqui
  };

  return (
    <EditorContainer>
      <TopBar>
        <button onClick={handleExport}>Salvar como Imagem</button>
      </TopBar>
      <Content>
        <LayerList />
        <CanvasArea />
        <ElementList />
      </Content>
    </EditorContainer>
  );
};

export default Editor;
```

## File: src/components/ImageEditor/Editor/style.ts
```typescript
import styled from 'styled-components';

export const EditorContainer = styled.div`
  display: flex;
  flex-direction: column;
  flex: 1;
  height: 100vh;
  overflow: hidden;
`;

export const Content = styled.div`
  display: flex;
  flex: 1;
`;

export const TopBar = styled.div`
  display: flex;
  align-items: center;
  gap: 10px;
  background-color: #777777;
  padding: 5px;
`;
```

## File: src/components/ImageEditor/ElementList/index.tsx
```typescript
// src/components/ImageEditor/LayerList/index.ts
import React from 'react';
import { v4 as uuidv4 } from 'uuid';
import { ElementListContainer } from './style';
import { useRecoilState } from 'recoil';
import { layersState, selectedLayerIdState } from '@/state/atoms';
import { LayerType } from '@/types';

const ElementList: React.FC = () => {
  const [layers, setLayers] = useRecoilState(layersState);

  // Função para adicionar uma nova camada ao carregar uma imagem
  const handleUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files) {
      Array.from(files).forEach((file) => {
        if (!file.type.startsWith('image/')) {
          alert('Por favor, selecione um arquivo de imagem.');
          return;
        }

        const reader = new FileReader();
        reader.onload = () => {
          const img = new window.Image();
          img.src = reader.result as string;
          img.onload = () => {
            const newLayer: LayerType = {
              id: uuidv4(),
              type: 'image',
              name: file.name,
              visible: true,
              locked: false,
              image: img,
              x: 50,
              y: 50,
              width: img.width,
              height: img.height,
              rotation: 0,
              zIndex: layers.length,
            };
            setLayers((prev) => [...prev, newLayer]);
          };
        };
        reader.readAsDataURL(file);
      });
    }
  };

  // Função para adicionar uma nova camada de texto
  const handleAddText = () => {
    const newLayer: LayerType = {
      id: uuidv4(),
      name: 'Camada de Texto',
      type: 'text',
      visible: true,
      locked: false,
      x: 100,
      y: 100,
      rotation: 0,
      width: 200,
      height: 50,
      zIndex: layers.length,
      text: 'Clique duplo para editar o texto',
      fontSize: 24,
      fontFamily: 'Arial',
      fill: '#000000',
    };
    setLayers((prev) => [...prev, newLayer]);
  };

  return (
    <ElementListContainer>
      <button onClick={handleAddText}>Adicionar Texto</button>
      <input type="file" title="Teste" onChange={handleUpload} multiple />
    </ElementListContainer>
  );
};

export default ElementList;
```

## File: src/components/ImageEditor/ElementList/style.ts
```typescript
import styled from 'styled-components';

export const ElementListContainer = styled.div`
  display: flex;
  flex-direction: column;
  width: 400px;
  border-left: 1px solid #ccc;
  overflow-y: auto;
  background-color: #fafafa;
`;
```

## File: src/components/ImageEditor/LayerItem/index.tsx
```typescript
// src/components/ImageEditor/LayerItem/index.ts
import React from 'react';
import { LayerType } from '@/types';
import { TextAa, Image, Eye, EyeSlash, Lock, LockOpen, ArrowUp, ArrowDown, Trash } from '@/icons';
import { LayerItemContainer, LayerNameInput, IconButton } from './style';

interface LayerItemProps {
  layer: LayerType;
  isSelected: boolean;
  onSelect: (id: string) => void;
  onToggleVisible: (id: string) => void;
  onToggleLocked: (id: string) => void;
  onRename: (id: string, name: string) => void;
  onDelete: (id: string) => void;
  onReorder: (id: string, direction: 'up' | 'down') => void;
}

const LayerItem: React.FC<LayerItemProps> = ({
  layer,
  isSelected,
  onSelect,
  onToggleVisible,
  onToggleLocked,
  onRename,
  onDelete,
  onReorder,
}) => {
  return (
    <LayerItemContainer selected={isSelected} onClick={() => onSelect(layer.id)}>
      {layer.type === 'text' ? <TextAa style={{ color: 'black' }} /> : <Image style={{ color: 'black' }} />}
      {/* Campo para renomear a camada */}
      <LayerNameInput value={layer.name} onChange={(e) => onRename(layer.id, e.target.value)} />
      {/* Botão para alternar visibilidade */}
      <IconButton
        onClick={(e) => {
          e.stopPropagation();
          onToggleVisible(layer.id);
        }}>
        {layer.visible ? <Eye style={{ color: 'black' }} /> : <EyeSlash style={{ color: 'black' }} />}
      </IconButton>
      {/* Botão para alternar bloqueio */}
      <IconButton
        onClick={(e) => {
          e.stopPropagation();
          onToggleLocked(layer.id);
        }}>
        {layer.locked ? <Lock style={{ color: 'black' }} /> : <LockOpen style={{ color: 'black' }} />}
      </IconButton>
      {/* Botões para reordenar */}
      <IconButton
        onClick={(e) => {
          e.stopPropagation();
          onReorder(layer.id, 'up');
        }}>
        <ArrowDown style={{ color: 'black' }} />
      </IconButton>
      <IconButton
        onClick={(e) => {
          e.stopPropagation();
          onReorder(layer.id, 'down');
        }}>
        <ArrowUp style={{ color: 'black' }} />
      </IconButton>
      {/* Botão para deletar a camada */}
      <IconButton
        onClick={(e) => {
          e.stopPropagation();
          onDelete(layer.id);
        }}>
        <Trash style={{ color: 'black' }} />
      </IconButton>
    </LayerItemContainer>
  );
};

export default LayerItem;
```

## File: src/components/ImageEditor/LayerItem/style.ts
```typescript
import styled from 'styled-components';

export const LayerItemContainer = styled.div<{ selected: boolean }>`
  display: flex;
  align-items: center;
  background-color: ${(props) => (props.selected ? '#c5c5c5' : '#eeeeee')};
  padding: 5px;
  margin: 5px;
  cursor: pointer;

  &:hover {
    background-color: #e8e8e8;
  }
`;

export const LayerNameInput = styled.input`
  flex-grow: 1;
  margin-left: 5px;
  margin-right: 5px;
  border: none;
  background: transparent;
  border-bottom: 1px solid #ccc;
  outline: none;
`;

export const IconButton = styled.button`
  background: none;
  border: none;
  margin: 0 2px;
  cursor: pointer;
  font-size: 16px;

  &:hover {
    color: #007bff;
  }
`;
```

## File: src/components/ImageEditor/LayerList/index.tsx
```typescript
// src/components/ImageEditor/LayerList/index.ts
import React from 'react';
import LayerItem from '../LayerItem';
import { LayerListContainer } from './style';
import { useRecoilState } from 'recoil';
import { layersState, selectedLayerIdState } from '@/state/atoms';
import { LayerType } from '@/types';

const LayerList: React.FC = () => {
  const [layers, setLayers] = useRecoilState(layersState);
  const [selectedLayerId, setSelectedLayerId] = useRecoilState(selectedLayerIdState);

  // Função para atualizar uma camada específica
  const updateLayer = (id: string, attrs: Partial<LayerType>) => {
    setLayers((prevLayers) => prevLayers.map((layer) => (layer.id === id ? { ...layer, ...attrs } : layer)));
  };

  // Funções para manipulação das camadas
  const handleSelectLayer = (id: string) => {
    setSelectedLayerId(id);
  };

  const handleToggleVisible = (id: string) => {
    const layer = layers.find((layer) => layer.id === id);
    if (layer) {
      updateLayer(id, { visible: !layer.visible });
    }
  };

  const handleToggleLocked = (id: string) => {
    const layer = layers.find((layer) => layer.id === id);
    if (layer) {
      updateLayer(id, { locked: !layer.locked });
    }
  };

  const handleDeleteLayer = (id: string) => {
    setLayers((prevLayers) => prevLayers.filter((layer) => layer.id !== id));
    if (selectedLayerId === id) {
      setSelectedLayerId(null);
    }
  };

  const handleRenameLayer = (id: string, name: string) => {
    updateLayer(id, { name });
  };

  const handleReorderLayer = (id: string, direction: 'up' | 'down') => {
    setLayers((prevLayers) => {
      const index = prevLayers.findIndex((layer) => layer.id === id);
      if (index < 0) return prevLayers;

      let newIndex = index;
      if (direction === 'up' && index > 0) {
        newIndex = index - 1;
      } else if (direction === 'down' && index < prevLayers.length - 1) {
        newIndex = index + 1;
      } else {
        return prevLayers;
      }

      const newLayers = [...prevLayers];
      [newLayers[index], newLayers[newIndex]] = [newLayers[newIndex], newLayers[index]];

      // Atualiza o zIndex das camadas
      return newLayers.map((layer, idx) => ({
        ...layer,
        zIndex: idx,
      }));
    });
  };

  return (
    <LayerListContainer>
      {layers
        .slice()
        .sort((a, b) => b.zIndex - a.zIndex) // Ordena as camadas para exibição
        .map((layer) => (
          <LayerItem
            key={layer.id}
            layer={layer}
            isSelected={selectedLayerId === layer.id}
            onSelect={handleSelectLayer}
            onToggleVisible={handleToggleVisible}
            onToggleLocked={handleToggleLocked}
            onRename={handleRenameLayer}
            onDelete={handleDeleteLayer}
            onReorder={handleReorderLayer}
          />
        ))}
    </LayerListContainer>
  );
};

export default LayerList;
```

## File: src/components/ImageEditor/LayerList/style.ts
```typescript
import styled from 'styled-components';

export const LayerListContainer = styled.div`
  width: 450px;
  border-right: 1px solid #ccc;
  overflow-y: auto;
  background-color: #fafafa;
`;
```

## File: src/state/atoms.ts
```typescript
// src/state/atoms.ts
import { atom } from 'recoil';
import { LayerType } from '@/types';

export const layersState = atom<LayerType[]>({
  key: 'layersState',
  default: [],
});

export const selectedLayerIdState = atom<string | null>({
  key: 'selectedLayerIdState',
  default: null,
});
```

## File: src/types/index.ts
```typescript
export interface LayerType {
  id: string;
  name: string;
  type: 'image' | 'text';
  visible: boolean;
  locked: boolean;
  x: number;
  y: number;
  rotation: number;
  width: number;
  height: number;
  zIndex: number;
  // Campos específicos para imagens
  image?: HTMLImageElement;
  // Campos específicos para texto
  text?: string;
  fontSize?: number;
  fontFamily?: string;
  fill?: string;
}
```
